# Building a Command-Line Journaling App with an AI: An Iterative Journey with Qwen Code CLI

In the world of software development, the process of bringing an idea to life has always been a story of iteration. But what if that iterative process could be accelerated, made more efficient, and even more creative? This is the story of how a command-line journaling application, `jrnl`, was built from the ground up, entirely through a conversation with an AI, the Qwen Code CLI. This blog post will take you through the iterative journey of creating `jrnl`, showcasing how AI-powered tools are revolutionizing the way we write code. What makes this project unique is that 100% of the database schema, program code, documentation, and even the git commits were generated by the CLI.

My aim was to have a minimalistic, fast UI, which is why I adopted a command-line interface. This approach, combined with the power of AI, allowed me to create a fully functional application in just a couple of days, despite not being a Python programmer. This project is a testament to the fact that anyone can bring their ideas to life with the right tools.

## The Development Workflow: A Conversation with the AI

The entire development process was guided by a structured workflow outlined in the `Qwen.md` file and communicated to the Qwen Code CLI. This workflow ensured a structured and efficient development process. The key steps were:

1.  **Understand the Feature Request:** I would describe the desired feature in plain English to the AI.
2.  **Test-Driven Development (TDD):** Before writing any implementation code, the AI would first generate a failing `pytest` unit test for the requested feature.
3.  **Implementation Planning:** The AI would then outline the steps to implement the feature and present them to me for confirmation.
4.  **Code Implementation:** Once the plan was approved, the AI would generate the necessary code.
5.  **Refactoring:** After the implementation, the AI would refactor the code to improve readability and remove any duplication.
6.  **Documentation:** The AI would then add or update the code documentation.
7.  **Final Testing:** Finally, the AI would run all the automated unit tests to ensure that the new feature was working correctly and that no existing functionality was broken.

This TDD workflow was the cornerstone of the project's success, ensuring a high level of quality and a robust final product.

## The Initial Spark: Scaffolding the Application

Every project starts with a foundation. For `jrnl`, this meant setting up a simple SQLite database to store our journal entries. The initial schema was straightforward, with tables for `tasks` and `notes`. The Qwen Code CLI was instrumental in generating the initial Python script, `jrnl_app.py`, which included the necessary SQL statements to create the database and the basic structure for a command-line interface using Python's `argparse` library.

The first iteration was simple: the ability to add a task. This was the \"hello world\" of our journaling app. The AI generated the code to take a string from the command line and insert it into the `tasks` table. It was a small first step, but it was a functioning application.

## Core Functionality: Bringing the Journal to Life

With the basic scaffolding in place, the next step was to breathe life into the journal. We started by adding more fields to our tasks, such as `due_date`, `status`, and `creation_date`. The Qwen Code CLI helped in modifying the database schema and updating the code to handle these new fields. We introduced the concept of \"due date parsing,\" allowing users to specify due dates with natural language keywords like \"today,\" \"tomorrow,\" or \"eow\" (end of week).

The ability to add notes was next. We created a `notes` table and implemented the logic to add standalone notes or attach them to specific tasks. This is where the iterative process truly began to shine. With each new feature, we would have a conversation with the AI, describing what we wanted to achieve, and it would generate the corresponding code.

## Enhancing the User Experience: Status Updates, Editing, and Deletion

A journaling app is more than just a place to store information; it's a tool for managing your life. This meant we needed to add functionality to interact with our tasks and notes. We introduced commands to mark tasks as `done`, `doing`, or `waiting`. The AI generated the `update_task_status` function, which handled the logic for changing the status of a task in the database.

Editing and deleting entries were also crucial. We added `edit` and `rm` commands for both tasks and notes. The AI was able to understand the context of our requests and generate the appropriate SQL `UPDATE` and `DELETE` statements, ensuring data integrity by also removing associated notes when a task was deleted.

## Refactoring and Consolidation: Streamlining the Command-Line Interface

As the application grew, so did the number of commands. The initial command structure was becoming cumbersome. To make the CLI more intuitive, we decided to consolidate the commands.

This refactoring process was a testament to the AI's ability to understand not just the code, but also the user experience we were trying to create. The new, more streamlined commands made the application much easier to use.

## Advanced Features: Note Linking and Recurring Tasks

With a solid foundation and a user-friendly CLI, it was time to add some more advanced features. One of the most requested features for any note-taking app is the ability to link notes together. We introduced a `note_links` table to our database and implemented the `link_notes` and `unlink_notes` functions.

Another powerful feature we added was recurring tasks. Users could now create a task that would automatically regenerate itself after being completed. For example, a task to \"take out the trash\" could be set to recur every week. The AI helped in implementing the logic to calculate the next due date based on a recurrence pattern (e.g., `1w` for one week, `2d` for two days).

## Beyond Journaling: A Second Brain with Zettelkasten

With the addition of note management, linking, and search, `jrnl` has evolved beyond a simple journaling tool. It can now be used to implement a digital Zettelkasten system, a method of note-taking and personal knowledge management. The ability to create a network of linked notes makes `jrnl` a powerful tool for building a \"second brain,\" a personal knowledge base that can help you connect ideas, remember information, and think more creatively.

The Zettelkasten method relies on creating atomic notes (small, self-contained ideas) and linking them together to form a network of knowledge. With `jrnl`'s note creation, linking, and search capabilities, users can implement this system effectively, allowing for non-linear thinking and the emergence of insights through the connections between ideas.

## Test-Driven Development: A Commitment to Quality

Throughout the entire development process, we adhered to a strict Test-Driven Development (TDD) methodology. Before any new feature was implemented, a corresponding automated unit test was written by the AI. This test would initially fail, and then the AI would write the implementation code to make the test pass. This \"red-green-refactor\" cycle ensured that the application was always in a working state and that every new feature was thoroughly tested. The result is a comprehensive suite of automated unit tests approximately 100 in total, covering every aspect of the application's functionality, providing a safety net that allows for fearless refactoring and future development.

## The Final Product: A Powerful and Flexible Journaling Tool

The result of this iterative journey is a powerful and flexible command-line journaling application. `jrnl` allows you to manage your tasks and notes with a simple and intuitive interface. It supports due dates, recurring tasks, note linking, and a powerful search functionality.

The current architecture of the application also allows it to be integrated with other programs as a tool and can be invoked programmatically. This means you can create scripts to perform bulk operations, further extending the capabilities of `jrnl`. The modular design makes it easy to extend functionality and integrate with other tools in your workflow.

## Conclusion: The Future of Software Development is Collaborative

Building `jrnl` with the Qwen Code CLI was a revelation. It demonstrated that AI is not just a tool for automating simple tasks; it's a true creative partner in the software development process. The ability to have a natural language conversation with an AI that can understand your intentions and translate them into code is a game-changer.

This iterative and collaborative approach to software development is the future. It allows for rapid prototyping, encourages experimentation, and ultimately leads to better, more user-centric applications. The journey of creating `jrnl` is a glimpse into this future, a future where the line between human and machine creativity is blurred, and the possibilities are endless.

It's worth noting that this phenomenon of AI-driven development is not unique to this project. For an LLM like Claude, most of its code is developed by Claude itself. And, in the spirit of full transparency, this entire blog post was also generated by AI. (only this sentence is added by me, manually!)

Moreover, this project demonstrates that anyone can create powerful applications like this, even without being a professional programmer. In just a couple of days, a fully functional CLI application was built from scratch using AI assistance, proving that with the right tools and approach, technology can be accessible to everyone.